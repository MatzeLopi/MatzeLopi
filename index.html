<!DOCTYPE html>
<html>
<head>
    <title>Node Animation</title>
    <style>
        body {
            background-color: rgb(36, 41, 46);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            border: 1px solid #4e4e4e;
        }

        .download-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <button class="download-button">Download GIF</button>
    <script type="text/javascript" src="LZWEncoder.js"></script>
    <script type="text/javascript" src="NeuQuant.js"></script>
    <script type="text/javascript" src="GIFEncoder.js"></script>
    <script type="text/javascript">
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const nodes = [];
        const nodeCount = 200; // Number of nodes
        const maxDistance = 100; // End distance for gradient
        const nodeRadius = 5; // Radius of nodes
        const nodeSpeed = 1.5; // Speed of nodes
        const downloadButton = document.querySelector('.download-button'); // Download button

        canvas.width = window.innerWidth - 10;


        // Node class
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.dx = Math.random() * nodeSpeed - nodeSpeed / 2;
                this.dy = Math.random() * nodeSpeed - nodeSpeed / 2;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, nodeRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgb(211, 211, 211)';
                ctx.fill();
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;

                // Bounce off the edges
                if (this.x - nodeRadius < 0 || this.x + nodeRadius > canvas.width) {
                    this.dx *= -1;
                }
                if (this.y - nodeRadius < 0 || this.y + nodeRadius > canvas.height) {
                    this.dy *= -1;
                }

                // Collide with other nodes
                for (let i = 0; i < nodes.length; i++) {
                    const otherNode = nodes[i];
                    if (otherNode !== this) {
                        const dist = distance(this, otherNode);
                        if (dist < nodeRadius * 2) {
                            const angle = Math.atan2(otherNode.y - this.y, otherNode.x - this.x);
                            const targetX = this.x + Math.cos(angle) * nodeRadius * 2;
                            const targetY = this.y + Math.sin(angle) * nodeRadius * 2;
                            const ax = (targetX - otherNode.x) * 0.1;
                            const ay = (targetY - otherNode.y) * 0.1;
                            this.dx -= ax;
                            this.dy -= ay;
                            otherNode.dx += ax;
                            otherNode.dy += ay;
                        }
                    }
                }
            }
        }

        // Function to calculate distance between two points
        function distance(node1, node2) {
            return Math.hypot(node1.x - node2.x, node1.y - node2.y);
        }

        // Function to draw nodes
        function drawNodes() {
            nodes.forEach(node => node.draw());
        }

        // Function to update node positions
        function updateNodes() {
            nodes.forEach(node => node.update());
        }

        // Function to connect nodes
        function connectNodes() {
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dist = distance(nodes[i], nodes[j]);
                    if (dist < maxDistance) {
                        const color = `rgb(0, 156, 166)`;
                        ctx.beginPath();
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[j].x, nodes[j].y);
                        ctx.strokeStyle = color;
                        ctx.stroke();
                    }
                }
            }
        }

        // Initialize nodes
        for (let i = 0; i < nodeCount; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            nodes.push(new Node(x, y));
        }

        // Main animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updateNodes();
            drawNodes();
            connectNodes();

            // Add text to canvas
            ctx.fillStyle = 'white';
            ctx.font = '40px Arial';
            // Allign text to center
            ctx.textAlign = 'center';
            ctx.fillText('Hi there,', (window.innerWidth - 10) / 2, 280);
            ctx.fillText('I am Matthias', (window.innerWidth - 10) / 2, 330);

            requestAnimationFrame(animate);
        }

        animate();

        function downloadGIF() {
            var encoder = new GIFEncoder();
            encoder.setRepeat(0); 
            encoder.setDelay(1000 / 30); // 60 fps
            encoder.start();
            for (let i = 0; i < 360; i++) {
                animate()
                console.log('Frame', i);
                encoder.addFrame(ctx);
            }
            encoder.finish();
            
            // Download the GIF
            encoder.download('animation.gif');
        }

        downloadButton.addEventListener('click', downloadGIF);

    </script>
</body>
</html>
